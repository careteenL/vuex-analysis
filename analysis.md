# 解析

## 前置知识
- 实现
- 类原型上面的方法如果是被解构使用，里面`this`指向就不是类实例的`this`了
  - 解决方法： 在`constructor`中为`this`重新绑定方法，在调用该方法之前获取到原型上的该方法并做保留。当解构该方法时，是使用的实例上的而非原型上。然后在重写的方法中调用原型上的方法，并为此指定`this`。即可保证this指向始终为类的实例。
- 递归实现无限命名空间
